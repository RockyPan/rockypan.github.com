---
layout: post
title: 用C++模板写的序列化框架
category: 技术
tags: [C++]
keywords: C++, 序列化, 模板
---

## 用C++模板写的序列化框架

在这个框架中包含了一个序列化的基本框架，一套基本的类型识别系统，可以识别基础类型，复杂类型，自定义类型，STD的容器类型，而且可以这个基础上进行递归的扩展。

可以将复杂的数据结构序列化到文件，并从文件中恢复。

包含了完整的自动单元测试，和测试案例。

写这个序列化框架最初是想用在一个大型的项目上，在那个项目中有一些相当复杂的在运行时构建出来的树形数据结构，如果可以将这个内存树序列化起来可以大大节约下次创建的时间。另外在自己做的一些小工具中，有些数据想保存在文件中，以后再从文件中读取，用序列化的方式也十分方便。而且那时正好系统的学习了一下C++模板技术，感觉在一般的编程活动中很难用到一些比较高级的模板技术，所以想用C++模板技术来写这个序列化框架。最后那个项目中没有使用这个序列化框架，但我至少达到了第二个目标，写这个序列化框架让我对C++模板技术有了更深层次的理解。

在这个框架中包含了一个序列化的基本框架，一套基本的类型识别系统，可以识别基础类型，复杂类型，自定义类型，STD的容器类型，而且可以这个基础上进行递归的扩展。

在写这个框架的同时，我也写了完整的测试案例。如果没有测试案例，要调试这样的框架可就真是难与登天，因为模板方面的错误，编译器报出来的信息很难看，有的根本就没用。

代码是在VC7.1下写的，也只能在VC7.1下用，VC6对于C++模板的支持非常有限，而其他的编译器在这方面的支持也有出入。如果要用于其他的编译器可能要修改部分类型识别方面的代码。测试框架我用的是cppunit(1.9.14)，这是个开源的测试框架，可以在www.xprogramming.com下载到。其中类型识别方面的代码我主要是参考了《C++ template》一书，和boost中的部分代码。

由于是用模板写的比MFC中的运行时序列化框架在效率上的表现要好得多。使用起来也相当的简单。如果要学习C++模板的高级技术，研究一下这个框架可以获益良多。由于是框架代码，我写得相当规范，有注释，也有完整的测试案例，可以进行自动的回归测试。

使用的方法比较简单请参考(fileRWTest.cpp)文件中的测试案例。

### 普通数据类型

`(unsigned char, unsigned short, unsigned int, unsigned long, signed char, signed short, signed int, signed long, bool, char, wchar_t, unsigned long long, signed long long, float, double, long double)`可以直接序列化及反序列化。

### 指针类型

会序列化指针具体指向的对象，如果指针指向的对象的类型是序列化框架无法识别的类型会报出编译错误。注意在反序列化时，只需要传一个空指针即可，序列化框架会将被序列化的对象的值反序列化到堆上，并将地址付给指针。如果传一个有值的指针，在DEBUG模式下会在运行时引发一个断言错误。在RELEASE下会导致原来指针指向的对象被泄漏。

### 字符指针

对于字符指针(即`char*`和`wchar_t*`类型)做为特殊处理，序列化框架认为字符指针为一个以`"0"`或`L"0"`结尾的字符串。会将整个字符串(除去`"/0"`和`L"0"`)序列化。反序列化时，传入一个空的字符指针即可。

需要注意的是字符串必须以`"/0"`和`L"0"`结尾，否则会发生严重的内存错误。

如果将字符串数组做字符指针用，以下代码也需要注意：

```
char * pstr = new char[10];
strcpy(pstr, "PK");
*pMedia << pstr;
--------------------------
char * pstr = 0;
*pMedia >> pstr;
```

反序列化后`pstr`指向的是一个长度为3的字符数组。也就是说，将原来数组`/0`之后的部分去掉了。

### 普通数据类型的数组

会将整个数组以内存拷贝的方式序列化到内存，即使没被真正赋值的元素。反序列化时传一个相同类型的数组即可。需要注意的是，传进的数组的容量必须大于或等于被序列化的数组的容量，否则会引发数组越界的内存错误，在DEBUG模式下，会引发一个断言错误。

### 非普通数据类型的数组

数组元素的类型可以是除普通数据类型之外的所有被序列化框架所支持的类型。序列化时会针对每一个元素调用序列化框架对它的具体序列化特化，反序列化时亦然。由于在RELEASE模式下类类型的数组在申明后，编译器会生成调用相应类的缺省构造函数的代码。但对于原始类型，如指针数组类型如果不显式的手工初始化，数组中的值是无意的随机值。这种情况序列化框架无法识别，会赞成严重的内存错误。另对于指针数组的某些元素为`NULL`的情况，序列化框架也无法处理，在DEBUG模式下会引发一个断言错误。

因此如果是指针数组除非数组中的元素全部为有意义的指针，否则不应该做为一个数组来序列化，而应该加入相应的遍历逻辑，将有意思的元素逐个序列化。

对于一般的数组，如果有意思的只是其中的少部分元素，也应该以上述方式进行序列化，以提高性能。

### 自定义数据类类型

不需要拷贝构造函数，不需要拷贝赋值函数，不需要析构函数的类。如老式的`struct`结构类型。这种类型可以通过直接拷贝内存而被高效的序列化及化序列化。只需要让一个类从`_data_class_tag`派生，序列化框架就会将它当成普通的数据类类型处理。

### 自定义复杂类型

对于非数据类类型，必须从`CSerializable`派生，关在类的定义中加入`SERIALIZABLE(name, x)`宏，`name`是该类的名字，`x`是相应的版本号。版本号的引入主要是避免在一个类被修改后，和以前生成的序列化文件一起使用，以免引起内存错误。在类中还必须实现`virtual bool Serialize(CMedia *) const;`函数，在该函数中写具体的序列化代码。该函数的内容很简单，按序列化及反序列化用为两段，简单的为每一个需要序列化及反序列化的成员函数调用即可，如下列：

```
if (pMedia->IsStoring()) {
   *pMedia << m_1 << m_2 << m_3 << m_4 << m_5;
   return true;
}
if (pMedia->IsLoading()) {
   *pMedia >> m_1 >> m_2 >> m_3 >> m_4 >> m_5;
   return true;
}
```

注意序列化和反序列化的顺序。

### `std::string`及`std::wstring`类型

使用比较简单。值得注意的是和将字符串数组做字符指针用的情况一样。如果申明了一个容量很大的`string`(一般是为了避免在追加时的内存重分配开销)，却只用了一小部分。序列化并反序列化，`string`对象的容量只是刚好有内存的那部分。

### `std::pair`类型

只要是`pair`的`first`和`second`必须是序列化框架所支持的类型就可以被正常的序列化及反序列化。

### std容器类型

`(vector,list,deque,stack,queue,set,multiset,map,multimap)`支持这些容器类型，其中容器中的元素类型必须是序列化框架所支持的类型。

---

> 评论人：Evan.Zhang   2007-12-31 00:11:40
您好潘先生，在网上看到您这篇文章感觉很吸引人。
但是搜索遍了所有的网站都没有下载到序列化框架的源代码。
如果方便可以发一份给我吗？谢谢您！
我的信箱是：littlerun@126.com
辛苦了！

> 评论人：畅   2005-10-13 12:16:38
我又来溜达了.
看了您昨天崽崽的日记,把我笑坏了.希望您能永远保持那轻松 自我调侃的心态 真好.
这个博客网,需要给钱否?