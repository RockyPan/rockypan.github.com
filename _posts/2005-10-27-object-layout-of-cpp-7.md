---
layout: post
title: C++对象布局及多态实现的探索(七)
category: 技术
tags: [C++]
keywords: C++, 内存对象布局
---

## C++对象布局及多态实现的探索(七)

### 构造函数中的虚成员函数调用 

在构造函数中调用虚成员函数，虽然这是个不很常用的技术，但研究一下可以加深对虚函数机制及对象构造过程的理解。这个问题也和一般直观上的认识有所差异。先看看下面的两个类定义。

```
struct C180
{
    C180() {
        foo();
        this->foo();
    }

    virtual foo() {
        cout << "<< C180.foo this: " << this << " vtadr: " << *(void**)this << endl;
    }
};

struct C190 : public C180
{
    C190() {}
    virtual foo() {
        cout << "<< C190.foo this: " << this << " vtadr: " << *(void**)this << endl;
    }
};
```

父类中有一个虚函数，并且父类在它的构造函数中调用了这个虚函数，调用时它采用了两种方法一种是直接调用，一种是通过`this`指针调用。同时子类又重写了这个虚函数。

我们可以来预测一下如果构造一个`C190`的对象会发生什么情况。

我们知道，在构造一个对象时，首先会按对象的大小得到一块内存(在heap上或在stack上)，然后会把指向这块内存的指针做为`this`指针来调用类的构造函数，对这块内存进行初始化。如果对象有父类就会先调用父类的构造函数(并依次递归)，如果有多个父类(多重继承)会依次对父类的构造函数进行调用，并会适当的调整`this`指针的位置。在调用完所有的父类的构造函数后，再执行自己的代码。

照上面的分析构造`C190`时也会调用`C180`的构造函数，这时在`C180`构造函数中的第一个`foo`调用为静态绑定，会调用到`C180::foo()`函数。第二个`foo`调用是通过指针调用的，这时多态行为会发生，应该调用的是`C190::foo()`函数。

执行如下代码：

```
C190 obj;
obj.foo();
```

结果为：

```
<< C180.foo this: 0012F7A4 vtadr: 0045C404
<< C180.foo this: 0012F7A4 vtadr: 0045C404
<< C190.foo this: 0012F7A4 vtadr: 0045C400
```

和我们的分析大相径庭。前2行是构造`C190`时的输出，后1行是我们用静态绑定方式调用的`C190::foo()`函数。第2行的输出说明多态行为并没有象预期的那样发生。而且比较输出的最后一列，发现在调用`C180`的构造函数时对象对应的虚表和构造后对象对应的虚表不是同一个。其实这正是奥秘的所在。

为此我查了一下C++标准规范。在12.7.3条中有明确的规定。这是一种特例，在这种情况下，即在构造子类时调用父类的构造函数，而父类的构造函数中又调用了虚成员函数，这个虚成员函数即使被子类重写，也不允许发生多态的行为。即，这时必须要调用父类的虚函数，而不子类重写后的虚函数。

我想这样做的原因是因为在调用父类的构造函数时，对象中属于子类部分的成员变量是肯定还没有初始化的，因为子类构造函数中的代码还没有被执行。如果这时允许多态的行为，即通过父类的构造函数调用到了子类的虚函数，而这个虚函数要访问属于子类的数据成员时就有可能出错。

我们看看VC7.1生成的汇编代码就可以很容易的理解这个行为了。 这是`C190`的构造函数：

```
00426FE0 push ebp
00426FE1 mov ebp,esp
00426FE3 sub esp,0CCh
00426FE9 push ebx
00426FEA push esi
00426FEB push edi
00426FEC push ecx
00426FED lea edi,[ebp+FFFFFF34h]
00426FF3 mov ecx,33h
00426FF8 mov eax,0CCCCCCCCh
00426FFD rep stos dword ptr [edi]
00426FFF pop ecx
00427000 mov dword ptr [ebp-8],ecx
00427003 mov ecx,dword ptr [ebp-8]
00427006 call 0041D451
0042700B mov eax,dword ptr [ebp-8]
0042700E mov dword ptr [eax],45C400h
00427014 mov eax,dword ptr [ebp-8]
00427017 pop edi
00427018 pop esi
00427019 pop ebx
0042701A add esp,0CCh
00427020 cmp ebp,esp
00427022 call 0041DDF2
00427027 mov esp,ebp
00427029 pop ebp
0042702A ret
```

开始部分的指令在前面几篇中陆续解释过，这里不再详述。我们看看第15是对父类的构造函数`C180::C180()`的调用，根据前文的说明，我们知道此时ecx中放的是`this`指针，也就是`C190`对象的地址。这时如果跳到`this`指针批向的地址看看会发现值为`0xcccccccc`即没有初始化，虚表指针也没有被初始化。那么我们跟着跳到`C180`的构造函数看看。

```
00427040 push ebp
00427041 mov ebp,esp
00427043 sub esp,0CCh
00427049 push ebx
0042704A push esi
0042704B push edi
0042704C push ecx
0042704D lea edi,[ebp+FFFFFF34h]
00427053 mov ecx,33h
00427058 mov eax,0CCCCCCCCh
0042705D rep stos dword ptr [edi]
0042705F pop ecx
00427060 mov dword ptr [ebp-8],ecx
00427063 mov eax,dword ptr [ebp-8]
00427066 mov dword ptr [eax],45C404h
0042706C mov ecx,dword ptr [ebp-8]
0042706F call 0041DA8C
00427074 mov ecx,dword ptr [ebp-8]
00427077 call 0041DA8C
0042707C mov eax,dword ptr [ebp-8]
0042707F pop edi
00427080 pop esi
00427081 pop ebx
00427082 add esp,0CCh
00427088 cmp ebp,esp
0042708A call 0041DDF2
0042708F mov esp,ebp
00427091 pop ebp
00427092 ret
```

看看第15行，在`this`指针的位置也就是对象的起始处，填入了一个4字节的值`0x0045C404`，其实这就是我们前面的打印过的`C180`的虚表地址。第16、17行和18、19行分别调用了两次`foo()`函数，用的都是静态绑定。这个就有点奇怪，因为对后一个调用我们使用了`this`指针，照理应该是动态绑定才对。可这里却是静态绑定，为什么编译器要做这个优化？我们继承往后看。

这个函数执行完后，我们再回到`C190`构造函数中，我们接着看`C190`构造函数汇编代码的第17行，这里又在对象的起始处重新填入了`0x0045C400`，覆盖了原来的值，而这个值就是我们前面打印过的真正的`C190`的虚表地址。

也就是说VC7.1是通过在调用构造函数的真正代码前把对象的虚指针值设置为指向对应类的虚表来实现C++规范的相应语义。C++标准中只规定了行为，并不规定具体编译器在实现这一行为时所用的方法。象我们上面看到的，即使是通过`this`指针调用，编译器也把它优化为静态绑定，也就是说即使不做这个虚指针的调整也不会有错。之所以要调整我想可能是防止在被调用的虚成员中又通过this指针来调用其他的虚函数，不过谁会这么变态呢？

还有值得一提的是，VC7.1中有一个扩展属性可以用来抑制编译器产生对虚指针进行调整的代码。我们可以在`C180`类的声明中加入这个属性。

```
struct __declspec(novtable) C180
{
    C180() {
        foo();
        this->foo();
    }

    virtual foo() {
        cout << "<< C180.foo this: " << this << " vtadr: " << *(void**)this << endl;
    }
};
```

这样再执行前面的代码，输出就会变成：

```
<< C180.foo this: 0012F7A4 vtadr: CCCCCCCC
<< C180.foo this: 0012F7A4 vtadr: CCCCCCCC
<< C190.foo this: 0012F7A4 vtadr: 0045C400
```

由于编译器抑制了对虚指针的调整所以在调`C180`的构造函数时虚指针的值没有初始化，这时我们才看到多亏编译器把第二个通过`this`指针对`foo`的调用优化成了静态绑定，否则由于虚指针没有初始化一定会出现一个指针异常的错误，这就回答我们上面的那个问题。

在这种情况下产生的汇编代码我就不列了，有兴趣的朋友可以自己去看一看。另外对于析构函数的调用，也请有兴趣的朋友自行分析一下。

另外这个属性在ATL的代码中大量的使用。在ATL中接口一般为纯虚基类，如果不用这个优化属性，由于在子类即实现类的构造函数中要调用父类的构造函数，而编译器产生的父类构造函数又要设置虚指针的值。所以编译器必须要把父类的虚表构建出来。而实际上这个虚表是没有任何意义的，因为ATL的纯虚接口类的虚函数都是无实现的。这样不仅仅是多了几行无用的设值指令，同时也浪费了空间。有兴趣的朋友可以自行验证一下。

对这个问题的兴趣源于张水松在工作中和我探讨的一个问题，在此也谢谢他。

(未完待续)

### 问题和答复

以下是网友在vchelp上的回复，我把它移到这里，便于我收集信息。呵呵。 

也就是说VC7.1是通过在调用构造函数的真正代码前把对象的虚指针值设置为指向对应类的虚表来实现C++规范的相应语义。C++标准中只规定了行为，并不规定具体编译器在实现这一行为时所用的方法。象我们上面看到的，即使是通过`this`指针调用，编译器也把它优化为静态绑定，也就是说即使不做这个虚指针的调整也不会有错。之所以要调整我想可能是防止在被调用的虚成员中又通过`this`指针来调用其他的虚函数，不过谁会这么变态呢？

调整虚指针是必需的。通过`this`指针调用被优化为静态绑定，那是因为你刚好在`C180`上定义了`foo`函数，按照标准语义，构造函数不再往下分派，因此必然只能调用`C180`上的`foo`函数。但如果`C180`从某个定义`foo`函数的基类继承，没有覆盖`foo`，那么必须使用虚函数才能找到正确的`foo`函数。

在被构造函数调用的函数（包括虚函数）里再调用其他虚函数也很正常，并非变态。Template method设计模式正好就是一个好例子。如果这个模式用于初始化过程，就正好出现了这种情况。

其实我在文中有说到这个现象的原因，也专门查了C++标准规范。”为此我查了一下C++标准规范。在12.7.3条中有明确的规定。“这和tmeplat模式没有关系。

设想一下两个类

```
struct A
{
    char * m_pStr1;
    A() {
        m_pStr1 = new char[1024];
        foo();
    }
    virtual foo() { strcpy(m_pStr1, "test");}
};

struct B
{
    char * m_pStr2;
    B() { m_pStr2 = new char[1024]; }
    virtual foo() { strcpy(m_pStr2, "test");}
};
```

如果没有这种在构造函数中抑制虚机制的行为。在我们构造对象B的时候，按照顺序会先调用父类的构造函数，在父类的构造函数中调用了虚函数`foo()`，由于我们假设虚机制没有被压抑，那么应该调用到`B::foo()`，而在`B:foo()`中用到了只有在类`B`的构造函数中才初始化的变量，因此程序崩溃（指针访问异常）。

这种行为直接和C++对象构造的语义相悖，因此C++标准规范特别指出，并规范了这种行为。建议去查一查C++标准规范。

至于利用C++的虚机制实现template模式，只要不在构造函数中调用虚方法，就可以完整实现template模式的语义。如果在构造函数中调用了，编译器也不会报错，但是语义已经不同了。你不可以通过在子类中重定义父类构造函数中调用的虚方法，来改变父类构造的过程。
