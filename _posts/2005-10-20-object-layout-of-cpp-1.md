---
layout: post
title: C++对象布局及多态实现的探索(一)
category: 技术
tags: [C++]
keywords: C++, 内存对象布局
---

## C++对象布局及多态实现的探索(一)

###前言

本文通过观察对象的内存布局，跟踪函数调用的汇编代码。分析了C++对象内存的布局情况，虚函数的执行方式，以及虚继承，等等。

写这篇文章源于我在论坛上看到的一个贴子。有人问VC使用了哪种方式来实现虚继承。当时我写了一点代码想验证一下，结果发现情况比我想象的要复杂。所以我就干脆认真把相关的问题都过了一遍，并记录成本文。

我对于C++对象模型的知识主要来自于Lippman的书《Inside the C++ Object Model》，中译版为候捷翻的《深度探索C++对象模型》，中英版我都看过，不过我还是推荐中译版，因为中译版的确翻得不错，而且候捷加入了很多的图，并修正了原版中的一些错误。

我所使用的编译器是VC7.1，文中的代码我都在VC7.1上验证通过。如果在其他的编译器下运行需要作相应的调整，即使是VC7.0和VC6也是如此。不同编译器产生的汇编代码也不一样，如果你在不同编译器上编译文中的代码生成出的汇编代码和我所列出的不同，也不足为奇。如果你想在其他的编译器上验证这些代码请自行做相应的改动。

另外我发现VC7.1在实现虚继承时所用的方法和Lippman在书中提到的微软所用的方法不同，不过那时还没有VC7.1。有趣的是，Lippman在写那本书时，是在迪斯尼工作，应该是做和三维影片的渲染软件相关的事。而现在他已经到了微软，相信应该是主导VC7.1编译器的设计工作。另外值得一提的是Herb，此人是C++标准委员会的一员，写过多本C++方面的经典书籍，现在也已经加入了微软。虽然我不是微软的“粉丝”，但对于VC不得不关注。VC8.0的beta版也已经出来了。

在后文中可以看到列出的很多汇编代码，有些明显效率很低。这可能是因为我没有打开编译器的优化开关。打开优化开关，设置不同的优化选项后，编译器可能产生出高效得多的汇编代码。有兴趣的朋友可以自行试试，并和文中列出的汇编代码做一下比较。

为了便于分析和观察对象的内存布局，我把代码生成时的结构成员对齐选项设置为1字节，默认为8字节。如果你在自己的工程下编译文中的代码，请做同样的设置。因为我写了一些函数打印对象中的布局信息，如果对象选项不是1字节，运行这些代码会出现指针异常错误。

文中所列出的代码可以从附件中下载到。代码所用到的宏的语义及参数说明，和代码中每一个类的简单描述可以在附录中找到。

### 普通类对象的内存布局 

首先我们从普通类对象的内存布局开始。C000为一个空类，定义如下：

```
struct C000
{
};
```

运行如下代码打印它的大小及对象中的内容。

```
PRINT_SIZE_DETAIL(C000)
```

结果为：

```
The size of C000 is 1
The detail of C000 is cc
```

可以看到它的大小为1字节，这是一个占位符。我们可以看到它的值是0xcc。在debug模式下，这表示是由编译器插入的调试代码所初始化的内存。在release模式下可能是个随机值，我测试时值为0x00。

定义两个类，C010和C011如下：

```
struct C010
{
    C010() : c_(0x01) {}
    void foo() { c_ = 0x02; }
    char c_;
};

struct C011
{
    C011() : c1_(0x02), c2_(0x03) {}
    char c1_;
    char c2_;
};
```

运行如下代码打印它们的大小及对象中的内容。

```
PRINT_SIZE_DETAIL(C010)
PRINT_SIZE_DETAIL(C012)
```

结果为：

```
The size of C010 is 1
The detail of C010 is 01
The size of C011 is 2
The detail of C011 is 02 03
```

我们从对象的内存输出中可以看到，它们的值就是我们在构造函数中赋的值，C010为0x01，C011为0x0203。大小分别为1、2。 定义C012类。

```
struct C012
{
    static int sfoo() { return 1; }
    int foo() { return 1; }
    char c_;
    static int i_;
};

int C012::i_ = 1;
```

在这个类中我们加入了一个静态数据成员，一个普通成员函数和一个静态成员函数。 运行如下代码打印它的大小及对象中的内容。

```
PRINT_SIZE_DETAIL(C012)
```

结果为：

```
The size of C012 is 1
The detail of C012 is cc
```

可以看到它的大小还是1字节，值为0xcc是因为我们没有初始化它，原因前面说过了。

从上面的结果我们可以映证，普通成员函数，静态成员函数，及静态成员变量皆不会在类的对象中有所表示，成员函数和对象的关联由编译器在编译时处理，正如我们会在后面看到的那样，编译器会在编译时决议出正确的普通成员函数地址，并将对象的地址以this指针的方式，做为第一个参数传递给普通成员函数，以此来进行关联。静态成员函数类似于全局函数，不和具体的对象关联。静态成员变量也一样。静态成员函数和静态成员变量和普通的全局函数及全局变量不同之处在于它们多了一层名字限定。

###普通继承类对象的内存布局

下面看看普通继承类对象的内存布局。

定义一个空类C014从C011继承，再定义C015也是一个空类从C010和C011继承。

```
struct C010
{
    C010() : c_(0x01) {}
    void foo() { c_ = 0x02; }
    char c_;
};

struct C011
{
    C011() : c1_(0x02), c2_(0x03) {}
    char c1_;
    char c2_;
};

struct C014 : private C011
{
};

struct C015 : public C010, private C011
{
};
```

运行如下代码打印它们的大小及对象中的内容。

```
PRINT_SIZE_DETAIL(C014)
PRINT_SIZE_DETAIL(C015)
```

结果为：

```
The size of C014 is 2
The detail of C014 is 02 03
The size of C015 is 3
The detail of C015 is 01 02 03
```

C014的大小为2字节，也就是C011的大小，对象的内存值也是在C011的构造函数中初始化的两个值0x0203。C015的大小为3字节，也就是C010和C011的大小之和，对象的内存值为0x010203。

这里我们可以发现父类的成员变量悉数被子类继承，并且于继承方式(公有或私有)无关，如C015是私有继承自C011。继承方式只影响数据成员的“能见度”。子类对象中属于从父类继承的成员变量由父类的构造函数初始化。通常会调用默认构造函数，除非子类在它的构造函数初始化列表中显式调用父类的非默认构造函数。如果没有指定，而父类又没有缺省构造函数，则会产生编译错误。

我们可以再加一层继承来验证一下。定义类C016，从C015继承，并有自己的4字节int成员变量。

```
struct C016 : C015
{
    C016() : i_(1) {}
    int i_;
};
```

运行如下代码打印它的大小及对象中的内容。

```
PRINT_SIZE_DETAIL(C016)
```

结果为：

```
The size of C016 is 7
The detail of C016 is 01 02 03 01 00 00 00
```

它的大小为7字节，也就是C015的大小(也即是C010和C011的大小和)加上自身的4字节int变量之和。同样对象的内存输出也验证了这一点，前三个字节为从父类继承的，后4个字节为自身的int变量，值为1。

因此关于普通继承，子类的对象布局为父类中的数据成员加上子类中的数据成员，多层继承时(如C016)，顶层类在前，多重继承时则最左父类在前。 （未完待续）
